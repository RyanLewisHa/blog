## 同步（Synchronization）

线程间的通信主要是通过共享访问字段以及其字段所引用的对象来实现的。这种形式的通信是非常有效的，但可能导致2种可能的错误：线程干扰（thread interference）和内存一致性错误（memory consistency errors）。同步就是要需要避免这些错误的工具。

但是，同步可以引入线程竞争（thread contention），当两个或多个线程试图同时访问相同的资源时，并导致了 Java 运行时执行一个或多个线程更慢，或甚至暂停他们的执行。饥饿（Starvation）和活锁 （livelock） 是线程竞争的表现形式。

### 线程干扰

描述当多个线程访问共享数据时是错误如何出现。

考虑下面的一个简单的类 Counter：

```java
public class Counter {
	private int c = 0;

	public void increment() {
		c++;
	}

	public void decrement() {
		c--;
	}

	public int value() {
		return c;
	}
}
```

其中的 increment 方法用来对 c 加1；decrement 方法用来对 c 减 1。然而，有多个线程中都存在对某个 Counter 对象的引用，那么线程间的干扰就可能导致出现我们不想要的结果。

线程间的干扰出现在多个线程对同一个数据进行多个操作的时候，也就是出现了“交错”。这就意味着操作是由多个步骤构成的，而此时，在这多个步骤的执行上出现了叠加。

Counter类对象的操作貌似不可能出现这种“交错(interleave)”，因为其中的两个关于c 的操作都很简单，只有一条语句。然而，即使是一条语句也是会被虚拟机翻译成多个步骤的。在这里，我们不深究虚拟机具体上上面的操作翻译成了什么样的步骤。只需要知道即使简单的 c++ 这样的表达式也是会被翻译成三个步骤的：

1. 获取 c 的当前值。
2. 对其当前值加 1。
3. 将增加后的值存储到 c 中。

表达式 c-- 也是会被按照同样的方式进行翻译，只不过第二步变成了减1，而不是加1。

假定线程 A 中调用 increment 方法，线程 B 中调用 decrement 方法，而调用时间基本上相同。如果 c 的初始值为 0，那么这两个操作的“交错”顺序可能如下：

1. 线程A：获取 c 的值。
2. 线程B：获取 c 的值。
3. 线程A：对获取到的值加1；其结果是1。
4. 线程B：对获取到的值减1；其结果是-1。
5. 线程A：将结果存储到 c 中；此时c的值是1。
6. 线程B：将结果存储到 c 中；此时c的值是-1。

这样线程 A 计算的值就丢失了，也就是被线程 B 的值覆盖了。上面的这种“交错”只是其中的一种可能性。在不同的系统环境中，有可能是 B 线程的结果丢失了，或者是根本就不会出现错误。由于这种“交错”是不可预测的，线程间相互干扰造成的 bug 是很难定位和修改的。

### 内存一致性错误

介绍了通过共享内存出现的不一致的错误。

内存一致性错误(Memory consistency errors)发生在不同线程对同一数据产生不同的“看法”。导致内存一致性错误的原因很复杂，超出了本书的描述范围。庆幸的是，程序员并不需要知道出现这些原因的细节。我们需要的是一种可以避免这种错误的方法。

避免出现内存一致性错误的关键在于理解 happens-before 关系。这种关系是一种简单的方法，能够确保一条语句对内存的写操作对于其它特定的语句都是可见的。为了理解这点，我们可以考虑如下的示例。假定定义了一个简单的 int 类型的字段并对其进行了初始化：

    int counter = 0;
    
该字段由两个线程共享：A 和 B。假定线程 A 对 counter 进行了自增操作：

    counter++;
    
然后，线程 B 打印 counter 的值：

    System.out.println(counter);
    
如果以上两条语句是在同一个线程中执行的，那么输出的结果自然是1。但是如果这两条语句是在两个不同的线程中，那么输出的结构有可能是0。这是因为没有保证线程 A 对 counter 的修改对线程 B 来说是可见的。除非程序员在这两条语句间建立了一定的 happens-before 关系。

我们可以采取多种方式建立这种 happens-before 关系。使用同步就是其中之一，这点我们将会在下面的小节中看到。

到目前为止，我们已经看到了两种建立这种 happens-before 的方式：

* 当一条语句中调用了 Thread.start 方法，那么每一条和该语句已经建立了 happens-before 的语句都和新线程中的每一条语句有着这种 happens-before。引入并创建这个新线程的代码产生的结果对该新线程来说都是可见的。
* 当一个线程终止了并导致另外的线程中调用 Thread.join 的语句返回，那么此时这个终止了的线程中执行了的所有语句都与随后的 join 语句随后的所有语句建立了这种 happens-before 。也就是说终止了的线程中的代码效果对调用 join 方法的线程来说是可见。

关于哪些操作可以建立这种 happens-before，更多的信息请参阅“[java.util.concurrent 包的概要说明](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility)”。

### 同步方法

描述了一个简单的做法，可以有效防止线程干扰和内存一致性错误。

Java 编程语言中提供了两种基本的同步用语：同步方法（synchronized methods）和同步语句（synchronized statements）。同步语句相对而言更为复杂一些，我们将在下一小节中进行描述。本节重点讨论同步方法。

我们只需要在声明方法的时候增加关键字 synchronized 即可：

```java
public class SynchronizedCounter {
	private int c = 0;

    public synchronized void increment() {
        c++;
    }

    public synchronized void decrement() {
        c--;
    }

    public synchronized int value() {
        return c;
    }
}
```

如果 count 是 SynchronizedCounter 类的实例，设置其方法为同步方法将有两个效果：

* 首先，不可能出现对同一对象的同步方法的两个调用的“交错”。当一个线程在执行一个对象的同步方式的时候，其他所有的调用该对象的同步方法的线程都会被挂起，直到第一个线程对该对象操作完毕。
* 其次，当一个同步方法退出时，会自动与该对象的同步方法的后续调用建立  happens-before 关系。这就确保了对该对象的修改对其他线程是可见的。

注意：构造函数不能是 synchronized ——在构造函数前使用 synchronized 关键字将导致语义错误。同步构造函数是没有意义的。这是因为只有创建该对象的线程才能调用其构造函数。

警告：在创建多个线程共享的对象时，要特别小心对该对象的引用不能过早地“泄露”。例如，假定我们想要维护一个保存类的所有实例的列表 instances。我们可能会在构造函数中这样写到：

    instances.add(this);
    
但是，其他线程可会在该对象的构造完成之前就访问该对象。

同步方法是一种简单的可以避免线程相互干扰和内存一致性错误的策略：如果一个对象对多个线程都是可见的，那么所有对该对象的变量的读写都应该是通过同步方法完成的（一个例外就是 final 字段，他在对象创建完成后是不能被修改的，因此，在对象创建完毕后，可以通过非同步的方法对其进行安全的读取）。这种策略是有效的，但是可能导致“活跃度（liveness）”问题。这点我们会在本课程的后面进行描述。


### 内部锁和同步

描述了一个更通用的同步方法，并介绍了同步是如何基于内部锁的。

同步是构建在被称为“内部锁（intrinsic lock）”或者是“监视锁（monitor lock）”的内部实体上的。（在 API 中通常被称为是“监视器（monitor）”。）内部锁在两个方面都扮演着重要的角色：保证对对象状态访问的排他性和建立也对象可见性相关的重要的“ happens-before。

每一个对象都有一个与之相关联动的内部锁。按照传统的做法，当一个线程需要对一个对象的字段进行排他性访问并保持访问的一致性时，他必须在访问前先获取该对象的内部锁，然后才能访问之，最后释放该内部锁。在线程获取对象的内部锁到释放对象的内部锁的这段时间，我们说该线程拥有该对象的内部锁。只要有一个线程已经拥有了一个内部锁，其他线程就不能再拥有该锁了。其他线程将会在试图获取该锁的时候被阻塞了。

当一个线程释放了一个内部锁，那么就会建立起该动作和后续获取该锁之间的 happens-before 关系。

#### 同步方法中的锁

当一个线程调用一个同步方法的时候，他就自动地获得了该方法所属对象的内部锁，并在方法返回的时候释放该锁。即使是由于出现了没有被捕获的异常而导致方法返回，该锁也会被释放。

我们可能会感到疑惑：当调用一个静态的同步方法的时候会怎样了，静态方法是和类相关的，而不是和对象相关的。在这种情况下，线程获取的是该类的类对象的内部锁。这样对于静态字段的方法是通过一个和类的实例的锁相区分的另外的锁来进行的。

#### 同步语句

另外一种创建同步代码的方式就是使用同步语句。和同步方法不同，使用同步语句是必须指明是要使用哪个对象的内部锁：

    public void addName(String name) {
        synchronized(this) {
            lastName = name;
            nameCount++;
        }
        nameList.add(name);
    }

在上面的示例中，方法 addName 需要对 lastName 和 nameCount 的修改进行同步，还要避免同步调用其他对象的方法（在同步代码段中调用其他对象的方法可能导致“活跃度（Liveness）”中描述的问题）。如果没有使用同步语句，那么将不得不使用一个单独的，未同步的方法来完成对 nameList.add 的调用。

在改善并发性时，巧妙地使用同步语句能起到很大的帮助作用。例如，我们假定类 MsLunch 有两个实例字段，c1 和 c2，这两个变量绝不会一起使用。所有对这两个变量的更新都需要进行同步。但是没有理由阻止对 c1 的更新和对 c2 的更新出现交错——这样做会创建不必要的阻塞，进而降低并发性。此时，我们没有使用同步方法或者使用和this 相关的锁，而是创建了两个单独的对象来提供锁。

```
public class MsLunch {
    private long c1 = 0;
    private long c2 = 0;
    private Object lock1 = new Object();
    private Object lock2 = new Object();

    public void inc1() {
        synchronized(lock1) {
            c1++;
        }
    }

    public void inc2() {
        synchronized(lock2) {
            c2++;
        }
    }
}
```

采用这种方式时需要特别的小心。我们必须绝对确保相关字段的访问交错是完全安全的。

#### 重入同步（Reentrant Synchronization）

回忆前面提到的：线程不能获取已经被别的线程获取的锁。但是线程可以获取自身已经拥有的锁。允许一个线程能重复获得同一个锁就称为重入同步（reentrant synchronization）。它是这样的一种情况：在同步代码中直接或者间接地调用了还有同步代码的方法，两个同步代码段中使用的是同一个锁。如果没有重入同步，在编写同步代码时需要额外的小心，以避免线程将自己阻塞。


### 原子访问

介绍了不会被其他线程干扰的做法的总体思路。

在编程中，原子性动作就是指一次性有效完成的动作。原子性动作是不能在中间停止的：要么一次性完全执行完毕，要么就不执行。在动作没有执行完毕之前，是不会产生可见结果的。

通过前面的示例，我们已经发现了诸如 c++ 这样的自增表达式并不属于原子操作。即使是非常简单的表达式也包含了复杂的动作，这些动作可以被解释成许多别的动作。然而，的确存在一些原子操作的：

* 对几乎所有的原生数据类型变量（除了 long 和  double）的读写以及引用变量的读写都是原子的。
* 对所有声明为 volatile 的变量的读写都是原子的，包括 long 和 double 类型。

原子性动作是不会出现交错的，因此，使用这些原子性动作时不用考虑线程间的干扰。然而，这并不意味着可以移除对原子操作的同步。因为内存一致性错误还是有可能出现的。使用 volatile 变量可以减少内存一致性错误的风险，因为任何对 volatile 变 量的写操作都和后续对该变量的读操作建立了 happens-before 关系。这就意味着对 volatile 类型变量的修改对于别的线程来说是可见的。更重要的是，这意味着当一个线程读取一个 volatile 类型的变量时，他看到的不仅仅是对该变量的最后一次修改，还看到了导致这种修改的代码带来的其他影响。

使用简单的原子变量访问比通过同步代码来访问变量更高效，但是需要程序员的更多细心考虑，以避免内存一致性错误。这种额外的付出是否值得完全取决于应用程序的大小和复杂度。

